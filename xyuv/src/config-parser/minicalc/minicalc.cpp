/* Generated by re2c 0.13.5 on Wed Aug 17 11:40:21 2016 */
#line 1 "minicalc.re"
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Stian Valentin Svedenborg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "minicalc.h"
#include "parser.h"
#include "ast.h"
#include <cassert>
#include <iostream>
#include <stdexcept>

MiniCalc::MiniCalc(const std::string & expression)
: expression(expression)
{
    parse_expression(expression);
}

MiniCalc::~MiniCalc() = default;

const uint64_t * MiniCalc::get_variable( const std::string & variable_name ) const {
    if (!variables) {
        return nullptr;
    }
    else {
        auto it = variables->find(variable_name);
        if (it == variables->end()) {
            return nullptr;
        }
        else {
            return &(it->second);
        }
    }
}


uint64_t MiniCalc::evaluate(const std::unordered_map<std::string, uint64_t> * variables) const {

    this->variables = variables;

    if (!parse_errors.empty()) {
        std::cout << "Parse error in expression: '" << expression << "'" << std::endl;
        for (auto & msg : parse_errors ) {
            std::cout << "  " << msg << std::endl;
        }
        return -1;
    }

    // Clear old runtime_errors
    runtime_errors.clear();
    int result = -1;
    try {
        result = root->evaluate();
    } catch( std::runtime_error & e ) {
        runtime_error(e.what());
    }

    // If the evaluation encountered run-time errors they are recorded here.
    if (!runtime_errors.empty()) {
        std::cout << "Could not evaluate expression: '" << expression << "'" << std::endl;
        for (auto & msg : runtime_errors ) {
            std::cout << "  " << msg << std::endl;
        }
        return -1;
    }

    return result;
}

void MiniCalc::set_root(node *node) {
    root.reset(node);
}

void MiniCalc::parse_error(const std::string & msg) const {
    parse_errors.push_back(msg);
}

void MiniCalc::runtime_error(const std::string & msg) const {
    runtime_errors.push_back(msg);
}

int MiniCalc::parse_expression(const std::string & expression)
{
    #define YYCTYPE         char
    int errorstate = 0;
	const char *YYCURSOR = expression.c_str();
	const char * const YYLIMIT  = YYCURSOR + expression.size() + 1 ;
    //const char * YYMARKER = NULL;
    //(void)YY


#define YYFILL(n)		{  }

    void * parser = ParseAlloc(malloc);

	for(;;)
	{

	    const char *token_begin = YYCURSOR;

#line 123 "<stdout>"
{
	YYCTYPE yych;

	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy24;
	case '\t':
	case ' ':	goto yy22;
	case '%':	goto yy14;
	case '(':	goto yy16;
	case ')':	goto yy18;
	case '*':	goto yy10;
	case '+':	goto yy6;
	case ',':	goto yy20;
	case '-':	goto yy8;
	case '/':	goto yy12;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy2;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy4;
	default:	goto yy26;
	}
yy2:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy35;
yy3:
#line 128 "minicalc.re"
	{
	                char * lend = NULL;
	                Token * tok = new Token;
                    tok->value = (int)strtol(token_begin, &lend, 10);
	                assert(lend == YYCURSOR);

	                Parse(parser, TOK_INT, tok, this);
	                continue;
	            }
#line 220 "<stdout>"
yy4:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy33;
yy5:
#line 138 "minicalc.re"
	{
        Token * tok = new Token;
        tok->identifier = std::string(token_begin, YYCURSOR);
        Parse(parser, TOK_IDENTIFIER, tok, this);
        continue;
    }
#line 233 "<stdout>"
yy6:
	++YYCURSOR;
#line 145 "minicalc.re"
	{   Parse(parser, TOK_PLUS, nullptr, this);continue;}
#line 238 "<stdout>"
yy8:
	++YYCURSOR;
#line 146 "minicalc.re"
	{   Parse(parser, TOK_MINUS, nullptr, this);continue;}
#line 243 "<stdout>"
yy10:
	++YYCURSOR;
	switch ((yych = *YYCURSOR)) {
	case '*':	goto yy30;
	default:	goto yy11;
	}
yy11:
#line 147 "minicalc.re"
	{   Parse(parser, TOK_MUL, nullptr, this);continue;}
#line 253 "<stdout>"
yy12:
	++YYCURSOR;
#line 148 "minicalc.re"
	{   Parse(parser, TOK_DIV, nullptr, this); continue;}
#line 258 "<stdout>"
yy14:
	++YYCURSOR;
#line 149 "minicalc.re"
	{   Parse(parser, TOK_MOD, nullptr, this); continue;}
#line 263 "<stdout>"
yy16:
	++YYCURSOR;
#line 151 "minicalc.re"
	{   Parse(parser, TOK_LPAREN, nullptr, this); continue; }
#line 268 "<stdout>"
yy18:
	++YYCURSOR;
#line 152 "minicalc.re"
	{   Parse(parser, TOK_RPAREN, nullptr, this); continue; }
#line 273 "<stdout>"
yy20:
	++YYCURSOR;
#line 153 "minicalc.re"
	{   Parse(parser, TOK_COMMA, nullptr, this); continue; }
#line 278 "<stdout>"
yy22:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy29;
yy23:
#line 156 "minicalc.re"
	{   continue; }
#line 286 "<stdout>"
yy24:
	++YYCURSOR;
#line 157 "minicalc.re"
	{
                    Parse(parser, 0, nullptr, this);
                    break;
                }
#line 294 "<stdout>"
yy26:
	++YYCURSOR;
#line 161 "minicalc.re"
	{	errorstate = 1; break; }
#line 299 "<stdout>"
yy28:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy29:
	switch (yych) {
	case '\t':
	case ' ':	goto yy28;
	default:	goto yy23;
	}
yy30:
	++YYCURSOR;
#line 150 "minicalc.re"
	{   Parse(parser, TOK_POW, nullptr, this); continue; }
#line 314 "<stdout>"
yy32:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy33:
	switch (yych) {
	case '.':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '[':
	case ']':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy32;
	default:	goto yy5;
	}
yy34:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy35:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy34;
	default:	goto yy3;
	}
}
#line 162 "minicalc.re"


	}

	ParseFree(parser, free);

	return errorstate;
}

// The resulting scanner can also be used as a standalone program to ease debugging.
#ifdef COMPILE_TEST_PROGRAM
#include <iostream>

int main(int argc, char **argv)
{
    using namespace std;

    char tmp[] =  "Trace: ";
    FILE * file = fopen("trace.txt", "w");
    ParseTrace(file, tmp);

    std::unordered_map<std::string, uint64_t> variables = {
        { "var1", 1},
        { "var2", 2},
        { "var3", 3},
    };

	if (argc > 1)
	{
        MiniCalc expr(argv[1]);
        cout << expr.evaluate(nullptr) << endl;

        return 0;
	}
	else
	{
	    std::cout << "error" << endl;
		return 1;
	}

    fclose(file);
}

#endif
